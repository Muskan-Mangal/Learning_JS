JaveScript is a Synchronus(executes in a specific order -> can only go to the next line once the current line is finished executing), single threaded (can only execute
one command at a time) language.
JS is a lossely typed or weekly types language which means irrespstive of datatype you can ssign anything to variable.


Execution context: 
Everything in JS happens inside execution context. an execution context is an abstract concept of an environment where the Javascript code is 
evaluated and executed. Whenever any code is run in JavaScript, it runs inside an execution context.The global execution context is created when a JavaScript script 
first starts to run, and it represents the global scope in JavaScript. A function execution context is created whenever a function is called, representing the 
function's local scope. 

It has 2 components:

1. Memory Component (variable environment, memory creation phase): where all the variables and functions are stored as key-value pairs. It goes throught the entire code
, allocates and reserves a memory for them. variables are intilialised with value undefined (a: undefined)and for functions it stores the whole code in memory space.
2. Code Component (Thread of execution, code execution phase): This is the place where code is executed one line at a time. in the second phase of creation of execution 
context which is code execution phase, the value of variables will actually get initialised (a=2). whenever a new function is INVOKED (actually called), a new functional 
execution context is created , in it's memory comp., it stores parameters and other variable and fucntions inside that function. Then hwen it encounters return keyword,
it return the control back to the execution context where the functions was invoked and that functional execution context is deleted. 

CALL STACK : 
It is like a real stack in data structures where data can be pushed and popped and follows the LIFO principle. We use call stack for memorizing which function is
running right now. Basically, a Javascript engine uses a call stack to manage execution context. When JS fucntion is run, the javascript engine builds a global 
execution context and pushes it to the top of the call stack. and when a function is called the javascript engine constructs a context for the function execution, 
places it at the top of the call stack, and begins the function’s execution. if the function calls another function javascript engine creates a new function execution 
context and pushes it to the top of the call stack. when it encoutners the return keyword that Exe. context is popped out. In the end, the Global execution context is
also deleted and the stack becomes empty.
In short , call stack maintains the order of execution of execution Contexts.

Hoisting :
Hoisting allows you to refer to JavaScript variables and functions prior to their declaration
JavaScript Hoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior
to execution of the code. Variables defined with let and const are hoisted to the top of the block, but not initialized. Meaning: The block of code is aware of the 
variable, but it cannot be used until it has been declared. Using a let variable before it is declared will result in a ReferenceError.
Also in case of let and const , you can't redeclare them , it will throw syntax error

Window:
window is the global object created along with global execution context. So a global object is created by JS engine (in chromes case it's v8 engine), in case of 
browsers it's called window. Whenever an execution context is created a "this" variable is also created. At the global level "this" points to the global object
( window object in case of browsers). Anything that is not inside a function is the "global space".Whenever we create any variables or functions in the 
"global space", they get attached to the global object( window object in case of browsers). (not in case of let and const)

Undefined :
means that a variable has been declared but has not been assigned a value. In JavaScript, properties and functions can only belong to objects. Since undefined is 
not an object type, calling a function or a property on such a variable causes the TypeError: Cannot read property of undefined.

SCOPE:
scope means where you can access a specific variable or function. there are two aspect to it. First what's the scope of variable B which means where I can access b,
and the other is b inside the scope of function C which means can I access variable b inside function c.
It determines the accessibility of variables, objects, and functions from different parts of the code.

https://javascript.plainenglish.io/scope-chain-and-lexical-environment-in-javascript-eb1f6e60997e

Lexical Scope
When we have a nested group of functions, the inner function has access to variables and other resources of the parent function. This means child functions are 
lexically bound to the execution context of their parents.

scope is directly dependent on the lexical environment.

Lexical environment:
whenver an execution context is created, a lexical environment is also created (in the memory comp. u get a reference to the lexical environment of it's parent). 
It's the local memory along withreference to the lexical environment of it's parent. Lexical as a term means in heirarchy like c is lexically inside a function a 
and fucntion a is lexically inside the global scope. For global execution lexical parents is NULL. 
So when searching for a variable in function B,it will first search in it's local memory (the memory comp of that fucntional xecution context) and then there it
will get reference to lexical environment of parent of fucntion B and wll search in their memory comp.

The lexical environment contains two components:

Environment record: It is the actual place where the variable and function declarations are stored.
Reference to the outer environment: It means it has access to its outer (parent) lexical environment.

SCOPE CHAIN 
SO this way or this mechanism of searching the scope is called scope chain. It's bacially the chain of all the lexical environments and parent references.
The scope chain helps to resolve variables. When a variable needs to resolve, JavaScript starts from the innermost level of the code and keeps jumping back to the 
parent scope until it finds the variable it’s looking for.

LET and CONST :

let and const are other ways of declaring a variable. They are hoisted which mean a memory space is created for them  Where they differ from other is declarations in 
the hoisting process is in their initialization. This makes them inaccessible (as such variables are in a temporal dead zone). They are not attached to the global 
object actually in a different memory space not like the global one. 
Const is more strict then var and let, in case of let you can initialise it later after declaring , it won't be accesible since till the time it's not initialised, 
it would be in temporal dead zone and will give reference error if tried to access, but in case of const, it needs to be initialised at the time of declaration only,
else it will throw syntax error and code won't even run.

Initialising variables at the top is good idea, helps shrinks TDZ to zero.

Temporal Dead Zone : A temporal dead zone (TDZ) is the block where a variable is inaccessible until the moment the computer initializes it with a value. 
kind of the ohase where the variable is hoisted and initialised.


